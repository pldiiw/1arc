# What's CHIP-8?

## Introduction

CHIP-8 is an interpreted programming language. It is composed of a
set of 35 instructions, each acting either on data registers or the screen
display.

## Data registers

The data registers are the primary utility for manipulating values. In Chip-8,
you have 16 data registers + 2 timer registers + 1 address-specific register:

 * Data registers:
   * `V0` through `VE` - Eight bits general purpose registers.
   * `VF` - Also a 1 byte register, but it is often modified by certain
     instructions to act as a flag.
 * Timers:
  * Delay timer - Its value will be decremented at a rate of 60Hz until it
    reaches `0x00`.
  * Sound timer - Similar to the delay timer, but when it is non-zero, a sound
    frequency is generated by the speaker. The minimum value at which it
    responds is `0x02`, setting the sound timer at `0x01` having no effect.
 * The `I` register - A 12 bits register dedicated to store memory addresses.

## Memory

In CHIP-8, you can access up to 4KB (4096 bytes) of RAM. The first 512 bytes
are reserved and should not be used. The original interpreter was located there
at that time.

```
Start of       Start of most             End of
CHIP-8 RAM     CHIP-8 programs           CHIP-8 RAM
+--------------+-------------------------+
| Reserved for | Program and data space  |
| interpreted  |                         |
+--------------+-------------------------+
0x000 (0)      0x200 (512)               0xFFF (4095)
```

It should be noted that CHIP-8 programs are normally stored in big-endian, i.e.
with the most significant byte of a two-byte instruction being stored first.

## The program counter, stack and stack pointer

These are 3 special registers, some calls them "pseudo-registers", inacessables
from a CHIP-8 program but essentials to the working of the interpreter.

The first, the program counter, 12 bits long, is used to store the currently
executed memory address. It is changed after an instruction is read, to next
memory address, or to a specific one when jumping for instance.

The stack is an array of sixteen 12 bits values. Each of these values also
stores memory addresses. You have in CHIP-8 two instructions used to call and
turn from subroutines, procedures. The one used to call a subroutine store the
address of the called procedure into the first empty value inside the
stack. This way, when we want to return from the subroutine, we take the last
stored value stored inside the stack and set the program counter to it.  

But how do we know which value inside the stack is the topmost one?

This is where the stack pointer comes to the rescue. It is simply a 4 bit
pseudo-register that gets incremented when we call a subroutine to point to
the new topmost memory address inside the stack and decremented when we return
from a subroutine.

## Keypad

The CHIP-8 programming language can receive input from a sixteen key keypad
like so:

```
+---------------+
| 1 | 2 | 3 | C |
| 4 | 5 | 6 | D |
| 7 | 8 | 9 | E |
| A | 0 | B | F |
+---------------+
```

## Display

The original implementation of the CHIP-8 language used a 64x32 monochrome
display.

```
+-------------------+
|(0,0)        (63,0)|
|                   |
|(0,31)      (63,31)|
+-------------------+
```

Drawing on the screen is done through the use of sprites, a group of bytes
which is the binary representation of the desired picture.  
A sprite can be 8 pixels wide and from one up to fifteen pixels high. One byte
corresponds to one row. The height of the sprite is specified through the
instruction that draws the sprite on the screen. See instruction `DXYN` for
more insight.  
The bits inside the sprites represent either to a transparent (black) pixel
when set to `0` and to a white pixel when set to `1`. When drawing, the sprite
data is XORed with the current graphics data on the screen. This enable the
programmer to erase a drawn sprite by redrawing it at the same location.  

All the sprites are stored in memory, just like the instructions. Concerning
where to place the sprite data, here's an extract from Mastering CHIP-8 by
Matthew Mikolay:

> As sprite data is stored in memory just like the actual CHIP-8 program
> instructions, care should be taken to prevent the interpreter from attempting
> to execute the sprite data as instructions. For this reason, it is advised to
> place all sprite data in a section of memory that sits independently of the
> main program memory. For example, the sprite data could be placed toward the
> beginning of the program, and preceded by a jump instruction, forcing the
> interpreter to skip over this data. In another case, sprite data could be
> placed at the end of the program, and the program could be coded in a way
> such that the sprite data would never be reached by the interpreter.

### Font

CHIP-8 contains a built-in font to allow simple output of characters. All
hexadecimal digits have a corresponding sprite data that is already stored in
the memory of the interpreter.

Here's a table of the font sprites and their corresponding sprite data:

```
+---------------------------+
| Sprite  | Hex  | Binary   |
+---------------------------+---------------------------+
| * * * * | 0xF0 | 11110000 |     *   | 0x20 | 00100000 |
| *     * | 0x90 | 10010000 |    **   | 0x60 | 01100000 |
| *     * | 0x90 | 10010000 |     *   | 0x20 | 00100000 |
| *     * | 0x90 | 10010000 |     *   | 0x20 | 00100000 |
| * * * * | 0xF0 | 11110000 |   * * * | 0x70 | 01110000 |
+---------------------------+---------------------------+
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
|       * | 0x10 | 00010000 |       * | 0x10 | 00010000 |
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
| *       | 0x80 | 10000000 |       * | 0x10 | 00010000 |
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
+---------------------------+---------------------------+
| *     * | 0x90 | 10010000 | * * * * | 0xF0 | 11110000 |
| *     * | 0x90 | 10010000 | *       | 0x80 | 10000000 |
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
|       * | 0x10 | 00010000 |       * | 0x10 | 00010000 |
|       * | 0x10 | 00010000 | * * * * | 0xF0 | 11110000 |
+---------------------------+---------------------------+
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
| *       | 0x80 | 10000000 |       * | 0x10 | 00010000 |
| * * * * | 0xF0 | 11110000 |     *   | 0x20 | 00100000 |
| *     * | 0x90 | 10010000 |   *     | 0x40 | 01000000 |
| * * * * | 0xF0 | 11110000 |   *     | 0x40 | 01000000 |
+---------------------------+---------------------------+
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
| *     * | 0x90 | 10010000 | *     * | 0x90 | 10010000 |
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
| *     * | 0x90 | 10010000 |       * | 0x10 | 00010000 |
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
+---------------------------+---------------------------+
| * * * * | 0xF0 | 11110000 | * * *   | 0xE0 | 11100000 |
| *     * | 0x90 | 10010000 | *     * | 0x90 | 10010000 |
| * * * * | 0xF0 | 11110000 | * * *   | 0xE0 | 11100000 |
| *     * | 0x90 | 10010000 | *     * | 0x90 | 10010000 |
| *     * | 0x90 | 10010000 | * * *   | 0xE0 | 11100000 |
+---------------------------+---------------------------+
| * * * * | 0xF0 | 11110000 | * * *   | 0xE0 | 11100000 |
| *       | 0x80 | 10000000 | *     * | 0x90 | 10010000 |
| *       | 0x80 | 10000000 | *     * | 0x90 | 10010000 |
| *       | 0x80 | 10000000 | *     * | 0x90 | 10010000 |
| * * * * | 0xF0 | 11110000 | * * *   | 0xE0 | 11100000 |
+---------------------------+---------------------------+
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
| *       | 0x80 | 10000000 | *       | 0x80 | 10000000 |
| * * * * | 0xF0 | 11110000 | * * * * | 0xF0 | 11110000 |
| *       | 0x80 | 10000000 | *       | 0x80 | 10000000 |
| * * * * | 0xF0 | 11110000 | *       | 0x80 | 10000000 |
+---------------------------+---------------------------+
```

## Instructions

`N` is a hexadecimal digit.  
`X` and `Y` represents arbitrary data registers.

### Arithmetic

 * `6XNN` - Store number `0xNN` in register `VX`
 * `8XY0` - Store the value of register `VY` in `VX`
 * `7XNN` - Add value `0xNN` to register `VX`
 * `8XY4` - Add value of register `VY` to `VX`. Set `VF` to `0x01` if carry
   occurs (i.e. the result is greater than 256), to `0x00` if it doesn't.
 * `8XY5` - Subtract `VY` from `VX`, setting `VF` to `0x00` if a borrow occurs,
   to `0x01` if it doesn't.
 * `8XY7` - Set `VX` to the value of `VY - VX`, setting `VF` to `0x00` if a
   borrow occurs, to `0x01` if it doesn't.

### Logic

 * `8XY1` - Set `VX` to `VX ∨ VY` (OR).
 * `8XY2` - Set `VX` to `VX ∧ VY` (AND).
 * `8XY3` - Set `VX` to `VX ⊻ VY` (XOR).
 * `8XY6` - Store the value of register `VY` shifted one bit to the right in
   register `VX`. Set `VF` to the least significant bit prior to the shift.
 * `8XYE` - Store the value of register `VY` shifted one bit to the left in
   register`VX`. Set `VF` to the most significant bit prior to the shift.

### Randomness

 * `CXNN` - Set `VX` to a pseudo-random number with a mask of `0xNN` (i.e. the
   drawn number goes through a logical AND with `0xNN` before being stored in
   `VX`).

### Jumps

 * `1NNN` - Jump to memory address `0xNNN` (i.e. continue program execution
   from this new address).
 * `BNNN` - Jump to address `0xNNN + V0`.

### Subroutines

 * `2NNN` - Execute subroutine starting at address `0xNNN`. Before changing the
   program counter to the new address, it increments the current one (as we
   don't want to re-execute the "call" instruction when we return from the
   subroutine), stores it inside the stack and increments the stack pointer.
 * `00EE` - Return from a subroutine. This means setting the program counter to
   the memory address inside the stack value the stack pointer points to and
   decrementing our stack pointer.
 * `0NNN` - Execute machine language subroutine at address `0xNNN` -
   **DEPRECATED**

### Conditional branching / Skips

 * `3XNN` - Skip the following instruction if `VX == 0xNN`.
 * `5XY0` - Skip the following instruction if `VX == VY`.
 * `4XNN` - Skip the following instruction if `VX != 0xNN`.
 * `9XY0` - Skip the following instruction if `VX != VY`.

### Timers

 * `FX15` - Set the delay timer to the value of register `VX`.
 * `FX07` - Store the current value of the delay timer in register `VX`.
 * `FX18` - Set the sound timer to the value of register `VX`.

### Keypad input

 * `FX0A` - Halts program execution until a key is pressed and store the result
   in register `VX`.
 * `EX9E` - Skip the following instruction if the key value in register `VX` is
   being pressed.
 * `EXA1` - Skip the following instruction if the key value in register `VX` is
   not being pressed.

### The `I` register

 * `ANNN` - Store memory address `0xNNN` in register `I`.
 * `FX1E` - Add the value stored in register `VX` to register `I`.

### Memory storage

 * `FX55` - Store values of registers `V0` through `VX` inclusive in memory
   starting at address stored in register `I`. Register `I` is set to
   `I + 0xX 1` afterwards.
 * `FX65` - Fill register `V0` through `VX` inclusive with the values stored in
   memory starting at address `I`. Register `I` is set to `I + 0xX + 1`
   afterwards.
 * `FX33` - Store the binary-coded decimal equivalent to the value of register
   `VX` at addresses `I`, `I+1` and `I+2`.

### Graphics

 * `DXYN` - Draw a sprite at position `VX, VY` with `0xN` bytes of sprite data
   starting at the address stored in `I`.
 * `00E0` - Clear the screen.
 * `FX29` - Set register `I` to the memory address of the sprite data
   corresponding to the hexadecimal digit stored in register `VX`.

## Resources

Mastering CHIP-8 by Matthew Mikolay: http://mattmik.com/files/chip8/mastering/chip8.html  
Cowgod's CHIP-8 Technical Reference v1.0: http://devernay.free.fr/hacks/chip8/C8TECH10.HTM
